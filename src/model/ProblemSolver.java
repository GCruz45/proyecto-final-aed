package model;

import exceptions.ElementAlreadyPresentException;
import exceptions.ElementNotFoundException;
import exceptions.WrongEdgeTypeException;
import exceptions.WrongGraphTypeException;
import org.graphstream.graph.*;
import org.graphstream.graph.implementations.MultiGraph;

import java.util.*;

/**
 * This class will use the algorithms implemented in the different classes along the program in order to solve two
 * specific competitive programming problems: Babel (UVa 11492) and Degrees of Separation (UVa 01056).<br>
 * Both this problems were chosen due to their solution being one that could be achieved by applying different algorithms
 * of the Graph data structure on them.<br>
 * This is a class that is part of a final algorithms and data structures course project.
 */
public class ProblemSolver {

    /**This field determines whether or not the problem to be solved is Degrees of Separation.*/
    private boolean dOP;

    /**This field will represent the graph visually, according to the graph generated by the problems given in input.*/
    private List<Graph> repGraphList;

    /**Set the field <code>dOP</code> to the value specified in the parameter.
     * @param d Whether the problem to be solved is Degrees of Separation or not.
     */
    public void setDOP(boolean d){
        dOP = d;
    }

    public ProblemSolver(){
        repGraphList = new ArrayList<>();
    }

    public String readInput(String input) throws ElementAlreadyPresentException, WrongEdgeTypeException, ElementNotFoundException, WrongGraphTypeException {
        if(dOP){
            return generateDOP(input);
        }else{
            return generateBabel(input);
        }
    }

    private String generateDOP(String in) throws ElementAlreadyPresentException, WrongEdgeTypeException, ElementNotFoundException, WrongGraphTypeException {
        //Graph to be replaced anytime a new network is created
        IGraph<String> graph;
        //The input to be solved
        String[] parts = in.split("\n");
        //The output of the problem
        String out="";
        //The name of the first person in a pair of people
        String person1;
        //The name of the second person in a pair of people
        String person2;
        //The Network represented in a single line
        String[] input;
        //The weight matrix after the Floyd-Warshall algorithm has been applied
        double[][] solution;
        //An auxiliary counter to keep track of the current line in input.
        int k = 0;
        //Number of edges in the network, maximum degree of separation possible
        int edges, degreeOfSeparation;
        //A counter that indicates the number of the network
        int counter = 0;
        while(!parts[k].equals("0 0")) {
            graph = new AdjacencyMatrixGraph<>(false, true);
            edges = Integer.parseInt(parts[k].split(" ")[1]);
            degreeOfSeparation = -1;
            counter++;
            input = parts[k + 1].split(" ");
            for (int i = 0; i < input.length - 1; i += 2) {
                person1 = input[i];
                person2 = input[i + 1];
                if (graph.getVertices().get(person1) == null) {
                    graph.addVertex(person1);
                }
                if (graph.getVertices().get(person2) == null) {
                    graph.addVertex(person2);
                }

                graph.addEdge(person1, person2, 1);
            }
            solution = GraphAlgorithms.floydWarshall(graph);
            for (int i = 0; i < graph.getVertexSize(); i++) {
                for (int j = 0; j < graph.getVertexSize(); j++) {
                    if (solution[i][j] > degreeOfSeparation) {
                        degreeOfSeparation = (int) solution[i][j];
                    }
                }
            }

            out += "Network " + counter + ": " + (degreeOfSeparation == Integer.MAX_VALUE ? "DISCONNECTED" : degreeOfSeparation) + "\n";
            repGraphList.add(getRepGraph(graph));
            k += 2;
        }
        return out;
    }

    private String generateBabel(String in) throws ElementAlreadyPresentException, ElementNotFoundException, WrongEdgeTypeException {
        String[] parts = in.split("\n");
        int k = 0;
        int words;
        String[] input;
        String startLang;
        String endLang;
        String lang1;
        String lang2;
        String edge;
        String out = "";
        int edgeSize;
        double[][] solution;
        IGraph<String> graph;
        while((words = Integer.parseInt(parts[k]))!= 0){
            graph = new AdjacencyMatrixGraph<>(false, true);
            input = parts[k+1].split(" ");
            startLang = input[0];
            endLang = input[1];
            graph.addVertex(startLang);
            graph.addVertex(endLang);
            for(int i = 0; i<words; i++){
                input = parts[k+1+i].split(" ");
                lang1 = input[0];
                lang2 = input[1];
                edge = input[2];
                edgeSize = input[2].length();
                if (graph.getVertices().get(lang1) == null)//Checks presence of lang1 in the graph.
                    graph.addVertex(lang1);
                if (graph.getVertices().get(lang2) == null)//Checks presence of lang2 in the graph.
                    graph.addVertex(lang2);

                if (graph.areConnected(lang1, lang2)) {
                    int index1 = graph.getIndex(lang1);
                    int index2 = graph.getIndex(lang2);
                    /*if (edge < graph.weightMatrix()[index1][index2]) {
                        graph.removeEdge(lang1, lang2);
                        graph.addEdge(lang1, lang2, edge);
                    }*/
                } else{}
                // graph.addEdge(lang1, lang2, edge);
            }
            solution = GraphAlgorithms.dijkstra(graph, startLang);
            if (solution[graph.getIndex(endLang)][0] != Double.MAX_VALUE)
                out += (int) solution[graph.getIndex(endLang)][0] + "\n";
            else
                out += "impossivel";

            repGraphList.add(getRepGraph(graph));
            k+=(2+words);
        }
        return out;
    }

    public Graph getRepGraph(IGraph<String> g){
        Graph ret = new MultiGraph("Problem graph");
        ret.setStrict(false);
        ret.setAutoCreate(true);
        for(Edge e: g.getEdgesArray()) {
            String v = null;
            String u = null;
        }

        return ret;
    }

    public List<Graph> getGraphs(){
        return repGraphList;
    }
}
